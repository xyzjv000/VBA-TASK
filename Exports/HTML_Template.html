<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chart Report</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: #f4f4f4;
      }
      .container {
        width: 90%;
        margin: auto;
        padding: 20px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      img {
        max-width: 100%;
        height: auto;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }
      table,
      th,
      td {
        border: 1px solid #ddd;
      }
      th,
      td {
        padding: 10px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
      }
      #hpfy24a,
      #pfify24,
      #fy25avspoe,
      #fy26avspoe {
        height: 400px;
      }
      #acap {
        height: 500px;
        width: 70%;
        min-width: 600px;
      }

      #fyamvspoe {
        height: 600px;
      }

      .chart-container {
        display: flex;
        flex-wrap: wrap;
      }

      .chart-item {
        flex: 1;
        min-width: 400px;
      }

      #rmpnmibase {
        min-height: 700px;
      }
      #nmi {
        width: 200px;
        padding: 10px;
        border-radius: 5px;
      }
      #loading {
        text-align: center;
      }
    </style>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
      }
      .footer {
        background-color: #f1f1f1;
        padding: 20px;
        border-top: 1px solid #ddd;
      }
      .footer-container {
        margin: 0 auto;
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }
      .footer-item {
        background-color: #ffffff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        flex: 1;
        min-width: 200px;
      }
      .footer-item h3 {
        margin: 0 0 10px;
        font-size: 16px;
        color: #333;
      }
      .footer-item p {
        margin: 0;
        font-size: 14px;
        color: #666;
      }
      @media (max-width: 768px) {
        .footer-item {
          flex: 1 1 100%;
        }
      }
    </style>
    <style>
      /* Responsive styles */
      @media (max-width: 768px) {
        #table1 thead, #table1 tbody {
          display: inline-grid;
          width: 50%;
        }
        #table1 #headerRow, #table1 #dataRow {
          display: inline-grid;
        }
        .table-container {
          overflow: scroll;
        }
        
        .container{
          width: 98%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="chart">
        <div class="chart-container">
          <div class="chart-item">
            <center><h3>Historical Performance FY2024 Actuals</h3></center>
            <div id="hpfy24a"></div>
          </div>
          <div class="chart-item">
            <center><h3>Percentage Fees in FY2024</h3></center>
            <div id="pfify24"></div>
          </div>
        </div>
        <div class="table-container">
          <table id="table1">
            <thead>
              <tr id="headerRow"></tr>
            </thead>
            <tbody>
              <tr id="dataRow"></tr>
            </tbody>
          </table>
        </div>
        <br />
        <hr />
        <!-- FY25 Actual vs POE -->
        <div>
          <div class="chart-item">
            <center><h3>FY25 Actual vs POE</h3></center>
            <div id="fy25avspoe"></div>
          </div>
        </div>
        <div class="table-container">
          <table id="table2">
            <thead>
              <tr id="headerRow"></tr>
            </thead>
            <tbody>
              <tr id="dataRow"></tr>
            </tbody>
          </table>
        </div>
        <br />
        <hr />
        <!-- FY26 Actual vs POE -->
        <div>
          <div class="chart-item">
            <center><h3>FY26 Actual vs POE</h3></center>
            <div id="fy26avspoe"></div>
          </div>
        </div>
        <div class="table-container">
          <table id="table3">
            <thead>
              <tr id="headerRow"></tr>
            </thead>
            <tbody>
              <tr id="dataRow"></tr>
            </tbody>
          </table>
        </div>
        <br />
        <hr />
        <!-- Actual Cost and Percentage -->
        <div>
          <div class="chart-item">
            <center><h3>Actual Cost and Percentage</h3></center>
            <div style="display: flex; flex-wrap: wrap; gap: 1rem">
              <div id="acap"></div>
              <div style="flex: 1" class="table-container">
                <table id="table5">
                  <thead>
                    <tr id="headerRow"></tr>
                  </thead>
                  <tbody>
                    <tr id="dataRow"></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        <br />
        <hr />
        <div>
          <div class="chart-item">
            <center><h3>Financial Year Actual Margin vs POE</h3></center>
            <div id="fyamvspoe"></div>
          </div>
        </div>
        <div class="table-container">
          <table id="table4">
            <thead>
              <tr id="headerRow"></tr>
            </thead>
            <tbody>
              <tr id="dataRow"></tr>
            </tbody>
          </table>
        </div>
        <hr />
        <br />
        <!-- Retail Margin per NMI Base -->
        <div>
          <div class="chart-item">
            <center><h3>Retail Margin per NMI Base</h3></center>
            <h4 id="loading">Loading please wait...</h4>
            <div id="rmpnmibase"></div>
            <label for="nmi">Filter by NMI</label>
            <select name="nmi" id="nmi"></select>
          </div>
        </div>
      </div>
    </div>
    <div class="footer">
      <div class="footer-container">
        <!-- Footer items will be injected here -->
      </div>
    </div>
    <script src="https://cdn.amcharts.com/lib/4/core.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/charts.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/maps.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/themes/animated.js"></script>
    <!-- functions -->
    <script>
      const transformDataForChart = (data, marginType) => {
        const marginData = data.find((entry) =>
          entry.typesofmargin.includes(marginType)
        );
        if (!marginData) {
          console.error("No data found for the specified typesofmargin.");
          return [];
        }

        return Object.keys(marginData.totals)
          .filter((key) => key.toLowerCase() !== "total")
          .map((key) => ({
            type: marginData.labels[key] || key,
            total: parseFloat(marginData.totals[key]),
          }));
      };
      const transformDataForCluster = (data, marginType) => {
        var marginData = [];
        if (marginType == null || marginType == "") {
          marginData = data;
        } else {
          marginData = data.filter((entry) =>
            entry.typesofmargin.includes(marginType)
          );
        }

        const combineData = (data) => {
          const combinedArray = [];

          data.forEach((entry) => {
            const { typesofmargin, totals, labels } = entry;

            Object.keys(totals).forEach((key) => {
              if (key.toLowerCase() !== "total") {
                combinedArray.push({
                  margin: typesofmargin,
                  type: labels[key] || key,
                  total: parseFloat(totals[key]),
                });
              }
            });
          });

          return combinedArray;
        };

        if (!marginData) {
          console.error("No data found for the specified typesofmargin.");
          return [];
        }

        return combineData(marginData);
      };
      const animatedPieChart = (data, chartId) => {
        am4core.useTheme(am4themes_animated);
        var chart = am4core.create(chartId, am4charts.PieChart3D);

        chart.data = data;
        chart.innerRadius = am4core.percent(40);

        var pieSeries = chart.series.push(new am4charts.PieSeries3D());
        pieSeries.dataFields.value = "total";
        pieSeries.dataFields.category = "type";

        pieSeries.labels.template.disabled = chartId != "acap";
        pieSeries.ticks.template.disabled = chartId != "acap";

        chart.legend = new am4charts.Legend();
        chart.legend.position = "right";
        chart.exporting.menu = new am4core.ExportMenu();
      };
      const xyChart = (data, chartId, seriesName) => {
        am4core.useTheme(am4themes_animated);
        var chart = am4core.create(chartId, am4charts.XYChart);

        chart.data = data;
        var categoryAxis = chart.xAxes.push(new am4charts.CategoryAxis());
        categoryAxis.dataFields.category = "type";
        categoryAxis.title.text = "Margins";

        categoryAxis.renderer.minGridDistance = 20;

        categoryAxis.renderer.labels.template.adapter.add(
          "dy",
          function (dy, target) {
            return 0;
          }
        );

        categoryAxis.renderer.labels.template.rotation = 45;
        categoryAxis.renderer.labels.template.horizontalCenter = "right";
        categoryAxis.renderer.labels.template.verticalCenter = "middle";
        categoryAxis.renderer.labels.template.fontSize = 12;

        var valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
        valueAxis.title.text = "Value";

        var series = chart.series.push(new am4charts.ColumnSeries());
        series.dataFields.valueY = "total";
        series.dataFields.categoryX = "type";
        series.name = seriesName;
        series.stacked = true;

        series.columns.template.tooltipText = "{categoryX}: [bold]{valueY}[/]";
        series.columns.template.fontSize = 14;

        series.tooltip.fontSize = 12;

        chart.yAxes.getIndex(0).renderer.labels.template.fontSize = 12;
        chart.xAxes.getIndex(0).renderer.labels.template.fontSize = 12;

        chart.cursor = new am4charts.XYCursor();
        chart.exporting.menu = new am4core.ExportMenu();
      };
      const populateTable1Data = (data) => {
        const headerRow = document.querySelector("#table1 #headerRow");
        const dataRow = document.querySelector("#table1 #dataRow");

        data.forEach((item) => {
          const th = document.createElement("th");
          th.textContent = item.type
            .replace(/([A-Z][a-z]+|[A-Z]+(?![a-z]))/g, " $1")
            .trim();
          headerRow.appendChild(th);
        });

        data.forEach((item) => {
          const td = document.createElement("td");
          td.textContent = parseFloat(item.total).toFixed(2);
          dataRow.appendChild(td);
        });
      };
      const clusteredChart = (data, chartId) => {
        am4core.useTheme(am4themes_animated);
        var chart = am4core.create(chartId, am4charts.XYChart);
        chart.colors.step = 2;

        chart.cursor = new am4charts.XYCursor();
        chart.cursor.behavior = "zoomXY";

        chart.legend = new am4charts.Legend();
        chart.legend.position = "top";
        chart.legend.paddingBottom = 20;
        chart.legend.labels.template.maxWidth = 95;

        var xAxis = chart.xAxes.push(new am4charts.CategoryAxis());
        xAxis.dataFields.category = "type";
        xAxis.renderer.cellStartLocation = 0.1;
        xAxis.renderer.cellEndLocation = 0.9;
        xAxis.renderer.grid.template.location = 0;

        function getExtremes(data) {
          const initialMax = -Infinity;
          const initialMin = Infinity;

          const extremes = data.reduce(
            (acc, item) => {
              const value = parseFloat(item.total);

              if (value > acc.max) {
                acc.max = value;
              }
              if (value < acc.min) {
                acc.min = value;
              }

              return acc;
            },
            { max: initialMax, min: initialMin }
          );

          return extremes;
        }

        const { max: highestValue, min: lowestValue } = getExtremes(data);

        var yAxis = chart.yAxes.push(new am4charts.ValueAxis());
        yAxis.min = chartId == "rmpnmibase" ? -50000 : lowestValue;
        yAxis.max = chartId == "rmpnmibase" ? 50000 : highestValue;
        yAxis.renderer.minGridDistance = 20;

        function createSeries(value, name) {
          var series = chart.series.push(new am4charts.ColumnSeries());
          series.dataFields.valueY = value;
          series.dataFields.categoryX = "type";
          series.name = name;
          if (chartId == "rmpnmibase") {
            series.columns.template.tooltipText = "{name}: [bold]{valueY}[/]";
          } else {
            series.columns.template.tooltipText =
              "{categoryX}: [bold]{valueY}[/]";
          }

          series.columns.template.fontSize = 14;

          series.events.on("hidden", arrangeColumns);
          series.events.on("shown", arrangeColumns);

          var bullet = series.bullets.push(new am4charts.LabelBullet());
          bullet.interactionsEnabled = true;
          bullet.dy = 30;
          bullet.label.fill = am4core.color("#ffffff");

          return series;
        }

        const categories = [...new Set(data.map((item) => item.type))];
        const seriesNames = [...new Set(data.map((item) => item.margin))];

        const chartData = categories.map((category) => {
          const dataPoint = { type: category };
          seriesNames.forEach((name) => {
            const entry = data.find(
              (d) => d.type === category && d.margin === name
            );
            dataPoint[name] = entry ? parseFloat(entry.total) : 0;
          });
          return dataPoint;
        });

        chart.data = chartData;

        seriesNames.forEach((name) => {
          createSeries(name, name);
        });

        function arrangeColumns() {
          var series = chart.series.getIndex(0);

          var w =
            1 -
            xAxis.renderer.cellStartLocation -
            (1 - xAxis.renderer.cellEndLocation);
          if (series.dataItems.length > 1) {
            var x0 = xAxis.getX(series.dataItems.getIndex(0), "categoryX");
            var x1 = xAxis.getX(series.dataItems.getIndex(1), "categoryX");
            var delta = ((x1 - x0) / chart.series.length) * w;
            if (am4core.isNumber(delta)) {
              var middle = chart.series.length / 2;

              var newIndex = 0;
              chart.series.each(function (series) {
                if (!series.isHidden && !series.isHiding) {
                  series.dummyData = newIndex;
                  newIndex++;
                } else {
                  series.dummyData = chart.series.indexOf(series);
                }
              });
              var visibleCount = newIndex;
              var newMiddle = visibleCount / 2;

              chart.series.each(function (series) {
                var trueIndex = chart.series.indexOf(series);
                var newIndex = series.dummyData;

                var dx = (newIndex - trueIndex + middle - newMiddle) * delta;

                series.animate(
                  { property: "dx", to: dx },
                  series.interpolationDuration,
                  series.interpolationEasing
                );
                series.bulletsContainer.animate(
                  { property: "dx", to: dx },
                  series.interpolationDuration,
                  series.interpolationEasing
                );
              });
            }
          }
        }

        chart.exporting.menu = new am4core.ExportMenu();
      };
      const populateTable2Data = (data, id) => {
        const headerRow = document.querySelector("#" + id + " #headerRow");
        const tbody = document.querySelector("#" + id + " tbody");

        const marginTypes = new Set();
        const typesOfMargins = new Set();

        data.forEach((item) => {
          marginTypes.add(item.type);
          typesOfMargins.add(item.margin);
        });

        headerRow.innerHTML =
          "<th></th>" +
          Array.from(marginTypes)
            .map(
              (type) =>
                "<th>" +
                type.replace(/([A-Z][a-z]+|[A-Z]+(?![a-z]))/g, " $1").trim() +
                "</th>"
            )
            .join("");

        const totalsMap = {};

        typesOfMargins.forEach((marginType) => {
          totalsMap[marginType] = {};
          marginTypes.forEach((type) => {
            totalsMap[marginType][type] = 0;
          });
        });

        data.forEach((item) => {
          if (totalsMap[item.margin]) {
            totalsMap[item.margin][item.type] += parseFloat(item.total);
          }
        });

        Object.keys(totalsMap).forEach((marginType) => {
          const row = document.createElement("tr");
          const marginTypeCell = document.createElement("td");
          marginTypeCell.textContent = marginType;
          row.appendChild(marginTypeCell);

          marginTypes.forEach((type) => {
            const td = document.createElement("td");
            td.textContent = totalsMap[marginType][type].toFixed(2);
            row.appendChild(td);
          });

          tbody.appendChild(row);
        });
      };
      const populateTable3Data = (data, id) => {
        const headerRow = document.querySelector("#" + id + " #headerRow");
        const tbody = document.querySelector("#" + id + " tbody");

        headerRow.innerHTML = "";
        tbody.innerHTML = "";

        headerRow.innerHTML = "<th>Margin</th><th>Total</th>";

        const totalsMap = {};

        data.forEach((item) => {
          if (!totalsMap[item.type]) {
            totalsMap[item.type] = 0;
          }
          totalsMap[item.type] += parseFloat(item.total);
        });

        Object.keys(totalsMap).forEach((type) => {
          const row = document.createElement("tr");

          const typeCell = document.createElement("td");
          typeCell.textContent = type;
          row.appendChild(typeCell);

          const totalCell = document.createElement("td");
          totalCell.textContent = totalsMap[type].toFixed(2);
          row.appendChild(totalCell);

          tbody.appendChild(row);
        });
      };
      const getUniqueValue = (data) => {
        const uniqueTypes = [
          ...new Set(
            data
              .map((item) => item.type)
              .filter((type) => type && type.trim() !== "(blank)")
          ),
        ];
        const selectAllOption = document.createElement("option");
        selectAllOption.value = "selectAll";
        selectAllOption.text = "Select All";
        select.insertBefore(selectAllOption, select.firstChild);

        uniqueTypes.forEach((type) => {
          const option = document.createElement("option");
          option.value = type;
          option.text = type;
          select.appendChild(option);
        });
      };
      const totalCost = (data) => {
        const totals = {};

        data.forEach((item) => {
          if (!totals[item.type]) {
            totals[item.type] = 0;
          }
          totals[item.type] += parseFloat(item.total);
        });

        return Object.keys(totals).map((type) => ({
          type: type,
          total: totals[type].toFixed(2),
        }));
      };
      const fyActualMarginVsPOE = (dataArr, chartId) => {
        am4core.useTheme(am4themes_animated);

        var chart = am4core.create(chartId, am4charts.XYChart);

        const transformedData = [];

        dataArr.forEach((margin) => {
          margin.totals.forEach((total) => {
            let existingEntry = transformedData.find(
              (entry) => entry.type === total.type
            );
            if (!existingEntry) {
              existingEntry = { type: total.type };
              transformedData.push(existingEntry);
            }

            existingEntry[margin.typesofmargin] = total.total;
          });
        });

        chart.data = transformedData;

        var categoryAxis = chart.xAxes.push(new am4charts.CategoryAxis());
        categoryAxis.dataFields.category = "type";
        categoryAxis.renderer.labels.template.fontSize = 14;
        categoryAxis.renderer.grid.template.location = 0;
        categoryAxis.renderer.minGridDistance = 20;
        categoryAxis.title.text = "Type";

        var valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
        valueAxis.renderer.minWidth = 35;
        valueAxis.title.text = "Total";

        dataArr.forEach((margin) => {
          var series = chart.series.push(new am4charts.LineSeries());
          series.dataFields.valueY = margin.typesofmargin;
          series.dataFields.categoryX = "type";
          series.name = margin.typesofmargin;
          series.strokeWidth = 2;
          series.tooltipText = "{name}: [bold]{valueY}[/]";

          var bullet = series.bullets.push(new am4charts.CircleBullet());
          bullet.circle.fill = am4core.color("#FF5733");
          bullet.circle.stroke = am4core.color("#fff");
          bullet.circle.strokeWidth = 2;
          bullet.circle.radius = 6;
        });

        chart.cursor = new am4charts.XYCursor();
        chart.cursor.behavior = "zoomY";

        chart.legend = new am4charts.Legend();

        chart.scrollbarX = new am4core.Scrollbar();
        chart.exporting.menu = new am4core.ExportMenu();
      };
      const nmiClusteredChart = (data, chartId) => {
        loadingElement.style.display = "block";
        if (nmiChartVar) {
          nmiChartVar.dispose();
        }
        am4core.useTheme(am4themes_animated);
        nmiChartVar = am4core.create(chartId, am4charts.XYChart);
        nmiChartVar.colors.step = 2;

        nmiChartVar.cursor = new am4charts.XYCursor();
        nmiChartVar.cursor.behavior = "zoomXY";

        nmiChartVar.legend = new am4charts.Legend();
        nmiChartVar.legend.position = "top";
        nmiChartVar.legend.paddingBottom = 20;
        nmiChartVar.legend.labels.template.maxWidth = 95;

        var xAxis = nmiChartVar.xAxes.push(new am4charts.CategoryAxis());
        xAxis.dataFields.category = "type";
        xAxis.renderer.cellStartLocation = 0.1;
        xAxis.renderer.cellEndLocation = 0.9;
        xAxis.renderer.grid.template.location = 0;

        function getExtremes(data) {
          const initialMax = -Infinity;
          const initialMin = Infinity;

          const extremes = data.reduce(
            (acc, item) => {
              const value = parseFloat(item.total);

              if (value > acc.max) {
                acc.max = value;
              }
              if (value < acc.min) {
                acc.min = value;
              }

              return acc;
            },
            { max: initialMax, min: initialMin }
          );

          return extremes;
        }

        const { max: highestValue, min: lowestValue } = getExtremes(data);

        var yAxis = nmiChartVar.yAxes.push(new am4charts.ValueAxis());
        yAxis.min = chartId == "rmpnmibase" ? -50000 : lowestValue;
        yAxis.max = chartId == "rmpnmibase" ? 50000 : highestValue;
        yAxis.renderer.minGridDistance = 20;

        function createSeries(value, name) {
          var series = nmiChartVar.series.push(new am4charts.ColumnSeries());
          series.dataFields.valueY = value;
          series.dataFields.categoryX = "type";
          series.name = name;
          series.columns.template.tooltipText = "{name}: [bold]{valueY}[/]";
          series.columns.template.fontSize = 14;

          series.events.on("hidden", arrangeColumns);
          series.events.on("shown", arrangeColumns);

          var bullet = series.bullets.push(new am4charts.LabelBullet());
          bullet.interactionsEnabled = true;
          bullet.dy = 30;
          bullet.label.fill = am4core.color("#ffffff");

          return series;
        }

        const categories = [...new Set(data.map((item) => item.type))];
        const seriesNames = [...new Set(data.map((item) => item.margin))];

        const chartData = categories.map((category) => {
          const dataPoint = { type: category };
          seriesNames.forEach((name) => {
            const entry = data.find(
              (d) => d.type === category && d.margin === name
            );
            dataPoint[name] = entry ? parseFloat(entry.total) : 0;
          });
          return dataPoint;
        });

        nmiChartVar.data = chartData;

        seriesNames.forEach((name) => {
          createSeries(name, name);
        });

        function arrangeColumns() {
          var series = nmiChartVar.series.getIndex(0);

          var w =
            1 -
            xAxis.renderer.cellStartLocation -
            (1 - xAxis.renderer.cellEndLocation);
          if (series.dataItems.length > 1) {
            var x0 = xAxis.getX(series.dataItems.getIndex(0), "categoryX");
            var x1 = xAxis.getX(series.dataItems.getIndex(1), "categoryX");
            var delta = ((x1 - x0) / nmiChartVar.series.length) * w;
            if (am4core.isNumber(delta)) {
              var middle = nmiChartVar.series.length / 2;

              var newIndex = 0;
              nmiChartVar.series.each(function (series) {
                if (!series.isHidden && !series.isHiding) {
                  series.dummyData = newIndex;
                  newIndex++;
                } else {
                  series.dummyData = nmiChartVar.series.indexOf(series);
                }
              });
              var visibleCount = newIndex;
              var newMiddle = visibleCount / 2;

              nmiChartVar.series.each(function (series) {
                var trueIndex = nmiChartVar.series.indexOf(series);
                var newIndex = series.dummyData;

                var dx = (newIndex - trueIndex + middle - newMiddle) * delta;

                series.animate(
                  { property: "dx", to: dx },
                  series.interpolationDuration,
                  series.interpolationEasing
                );
                series.bulletsContainer.animate(
                  { property: "dx", to: dx },
                  series.interpolationDuration,
                  series.interpolationEasing
                );
              });
            }
          }
        }

        nmiChartVar.exporting.menu = new am4core.ExportMenu();
        nmiChartVar.events.on("validated", function () {
          loadingElement.style.display = "none";
        });
        return nmiChartVar;
      };
    </script>
    <!-- variables and execution -->
    <script>
      var combinedJsonData = {{combinedJson}};
      var summaryJsonData = {{summaryJson}};
      var versionData = {{versionData}};
      var nmiJsonData = {{nmiJson}}

      var nmiChartVar;
      const typeList =[
            "RetailMargin",
            "Revenue",
            "Network",
            "Capacity",
            "WholesaleEnergy",
            "MarketFees",
            "ESS",
            "LGC",
            "STC",
            "Commission"
        ]

      const achievedMargin2024 = transformDataForChart(combinedJsonData, "Sum of Achieved Margin FY2024")
      const dataFy2024 =  transformDataForChart(combinedJsonData, "FY2024")
      const dataFy2025 =  transformDataForCluster(combinedJsonData, "FY2025")
      const dataFy2026 = transformDataForCluster(combinedJsonData, "FY2026")
      const dataRmperNMIBase = transformDataForCluster(nmiJsonData.filter(data => data.typesofmargin != "(blank)" && data.typesofmargin != "Grand Total"));
      var updatedDataRmperNMIBase = []
      var loadingElement = document.getElementById('loading');
      const select = document.getElementById('nmi');

      xyChart(achievedMargin2024, "hpfy24a", "Historical Performance FY2024 Actuals");
      animatedPieChart(achievedMargin2024, "pfify24");
      populateTable1Data(achievedMargin2024);
      clusteredChart(dataFy2025, "fy25avspoe");
      populateTable2Data(dataFy2025, 'table2');
      clusteredChart(dataFy2026, "fy26avspoe");
      populateTable2Data(dataFy2026, 'table3');
      animatedPieChart(totalCost(transformDataForCluster(summaryJsonData)), "acap");
      populateTable3Data(totalCost(transformDataForCluster(summaryJsonData)), 'table5');
      // Example usage
      const combinedSummary = []
      const prepareDateForChart = () => {
        function getLast6IfStartsWithFY(inputString) {
          if (inputString.length < 6) {
            return null;
          }

          // Extract the last 6 characters
          const last6 = inputString.slice(-6);

          if (last6.startsWith('FY')) {
            return last6;
          }
        }

        summaryJsonData.forEach((data, index) => {
          const dataOb = {
            typesofmargin: data.typesofmargin,
            totals: transformDataForChart(summaryJsonData, data.typesofmargin)
          }
          if (data.typesofmargin != "Grand Total")
            combinedSummary.push(dataOb)
        })
        combinedSummary.sort((a, b) => {
            if (a.typesofmargin < b.typesofmargin) return -1;
            if (a.typesofmargin > b.typesofmargin) return 1;
            return 0;
          });
      }
      prepareDateForChart()

      fyActualMarginVsPOE(combinedSummary, "fyamvspoe");
      populateTable2Data(transformDataForCluster(combinedJsonData), 'table4');
      nmiClusteredChart(dataRmperNMIBase, "rmpnmibase");
      getUniqueValue(dataRmperNMIBase)
    </script>
    <!-- footer -->
    <script>
      const footerContainer = document.querySelector(".footer-container");

      versionData.forEach((item) => {
        const footerItem = document.createElement("div");
        footerItem.className = "footer-item";
        footerItem.innerHTML ="<h3>" + item.version + "</h3>" +
          "<p>" + item.effectiveDate + "</p>";
        footerContainer.appendChild(footerItem);
      });
    </script>
    <!-- event listener -->
    <script>
      function reloadChart(newData) {
        nmiClusteredChart(newData, "rmpnmibase");
        isChartLoading = true;
      }
      select.addEventListener("change", function () {
        if (select.value === "selectAll") {
          updatedDataRmperNMIBase = dataRmperNMIBase;
          for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value !== "selectAll") {
              select.options[i].selected = true; // Select all other options
            }
          }
        } else {
          updatedDataRmperNMIBase = transformDataForCluster(
            nmiJsonData.filter(
              (data) =>
                data.typesofmargin != "(blank)" &&
                data.typesofmargin != "Grand Total"
            )
          ).filter((data) => data.type == select.value);
        }
        reloadChart(updatedDataRmperNMIBase);
        console.log("dataRmperNMIBase", updatedDataRmperNMIBase, select.value);
      });
    </script>
  </body>
</html>
